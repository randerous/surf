package SB_Service
public
	with SB_Processor;
	with SB_Result_IO;
	with SB_Base_IO;
	with SB_Arg_IO;
	with SB_Route_Table;

	abstract Service
		features
			CreatePipeArgs: feature group SB_Arg_IO::CreatePipeArgs;
			DeletePipeArgs: feature group SB_Arg_IO::DeletePipeArgs;
			SubscribeArgs: feature group SB_Arg_IO::SubscribeArgs;
			UnsubscribeArgs: feature group SB_Arg_IO::UnsubscribeArgs;
			SendMsgArgs: feature group SB_Arg_IO::SendMsgArgs;
			
			OutMsgs: feature group SB_Route_Table::RouteOutput;
--			RcvMsg: feature group SB_Interface::P_RcvMsg;

			annex agree{**
--				we use lock to sychronize the operation to shared data,such as Pipe info and Route info
				assume "No Create and Delete pipe at the same time": not(CreatePipeArgs.a.In_Used = true
					and DeletePipeArgs.a.In_Used = true
				);
				
				assume "No Subscribe and UnSubscribe at the same time": not(SubscribeArgs.a.In_Used = true
					and UnsubscribeArgs.a.In_Used = true
				);
			**};
	end Service;
 
--     SB consist of :
--     shareData: store and maintain all used pipe statues and all route info.
--     all functions can read it from the connection from  local data to old pipe or old route, respectively 
--	   we use lock to sychronize the operation to shared data,such as Pipe info and Route info
--       so we can choose which info  will be store in share data  by call result.
--       the result will only be concerning with the cmd called.
	abstract implementation Service.impl
		subcomponents
			CreatePipe: abstract SB_Processor::CreatePipe;
			DeletePipe: abstract SB_Processor::DeletePipe;
			Subscribe: abstract SB_Processor::Subscribe;
			Unsubscribe: abstract SB_Processor::Unsubscribe;
			SendMsg: abstract SB_Processor::SendMsg;
			
			ShareData: abstract ShareData;
		connections
			CreatePipeArg: feature group CreatePipeArgs <-> CreatePipe.Args;
			CreatePipeLocalData: feature group ShareData.OldPipeData -> CreatePipe.LocalDatas;
			CreatePipeResult: feature group CreatePipe.Results -> ShareData.CreatePipeResult;
			
			DeletePipeArg: feature group DeletePipeArgs <-> DeletePipe.Args;
			DeletePipeLocalData: feature group ShareData.OldPipeData -> DeletePipe.LocalDatas;
			DeletePipeResult: feature group DeletePipe.Results -> ShareData.DeletePipeResult;
			
			SubscribeArg: feature group SubscribeArgs <-> Subscribe.Args;
			SubscribeLocalData: feature group ShareData.OldRouteData -> Subscribe.LocalDatas;
			SubscribeResult: feature group Subscribe.Results -> ShareData.SubscribeResult;
			
			UnsubscribeArg: feature group UnsubscribeArgs <-> Unsubscribe.Args;
			UnsubscribeLocalData: feature group ShareData.OldRouteData -> Unsubscribe.LocalDatas;
			UnsubscribeResult: feature group Unsubscribe.Results -> ShareData.UnsubscribeResult;
			
			SendMsgArg: feature group SendMsgArgs <-> SendMsg.Args;
			SendMsgLocalData: feature group ShareData.OldRouteData -> SendMsg.LocalDatas;
--			SendMsgResult: feature group SendMsg.Results -> ShareData.SendMsgResult;
			SendMsgOutMsg: feature group SendMsg.OutMsgs -> OutMsgs;
		
			annex agree 
			{**
			-->* CreatePipe
			-->在SB服务中创建管道，即__使能__SB服务中的该APP指定的__管道__。
			-->* DeletePipe
			-->在SB服务中删除管道，即__不使能__SB服务中的该APP指定的__管道__。
			-->* Subscribe
			-->在SB服务中绑定管道和消息，即__使能__SB服务中的该APP指定的消息和管道的__路由项__。
			-->* Unsubscribe
			-->在SB服务中解绑管道和消息，即__不使能__SB服务中的该APP指定的消息和管道的__路由项__。
			-->* SendMsg
			-->传入消息，按照路由表路由消息。
				
			**};
	end Service.impl;

----------------ShareData can add processor result
--store and maintain pipe and route info

--Note:
--call to modify route or pipe, will be updated in ShareData in this time ,based on last OldData.,
--so, whenever a  call try to modify sth, it should base the last data. 
	abstract ShareData
		features
			OldPipeData: feature group SB_Base_IO::PipeOutput;
			OldRouteData: feature group SB_Base_IO::RouteOutput;
			CreatePipeResult: feature group SB_Result_IO::CreatePipeResult;
			DeletePipeResult: feature group SB_Result_IO::DeletePipeResult;
			SubscribeResult: feature group SB_Result_IO::SubscribeResult;
			UnsubscribeResult: feature group SB_Result_IO::UnsubscribeResult;
			SendMsgResult: feature group SB_Result_IO::SendMsgResult;
		annex agree {**
			--error num is defined in Results defining.
			--    for return value
			--    SUCCESS:0
			--    SB_BAD_ARGUMENT:3 
			eq SUCCESS : int = 0;
			eq SB_BAD_ARGUMENT: int  = 3;
			eq SB_MAX_PIPES_MET: int = 4;	
			
			eq Pipe_Changed : bool = (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS )or
						(DeletePipeResult.EvaluteValue.Cmd_Called = SUCCESS);
--		    respectively manage each pipe;
--initially, set pipe inuse into false
			guarantee "manage ES_Cmd_Pipe": OldPipeData.ES_CmdPipe.InUse = false -> 
			if (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 0)
			then (OldPipeData.ES_CmdPipe  = CreatePipeResult.Input.ES_CmdPipe)
			else if  (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 0)
			then (OldPipeData.ES_CmdPipe.InUse = false)
			else OldPipeData.ES_CmdPipe = pre(OldPipeData.ES_CmdPipe) ;
			
			
			guarantee "manage SB_Cmd_Pipe": OldPipeData.SB_CmdPipe.InUse = false -> 
			if (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 1)
			then (OldPipeData.SB_CmdPipe  = CreatePipeResult.Input.SB_CmdPipe)
			else if  (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 1)
			then (OldPipeData.SB_CmdPipe.InUse = false)
			else OldPipeData.SB_CmdPipe = pre(OldPipeData.SB_CmdPipe) ;
			
			guarantee "manage EVS_Cmd_Pipe": OldPipeData.EVS_CmdPipe.InUse = false -> 
			if (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 2)
			then (OldPipeData.EVS_CmdPipe  = CreatePipeResult.Input.EVS_CmdPipe)
			else if  (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 2)
			then (OldPipeData.EVS_CmdPipe.InUse = false)
			else OldPipeData.EVS_CmdPipe = pre(OldPipeData.EVS_CmdPipe) ;
			
			guarantee "manage TIME_Cmd_Pipe": OldPipeData.TIME_CmdPipe.InUse = false -> 
			if (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 3)
			then (OldPipeData.TIME_CmdPipe  = CreatePipeResult.Input.TIME_CmdPipe)
			else if  (CreatePipeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				CreatePipeResult.EvaluteValue.Modified_PipeId = 3)
			then (OldPipeData.TIME_CmdPipe.InUse = false)
			else OldPipeData.TIME_CmdPipe = pre(OldPipeData.TIME_CmdPipe) ;
			
			
		   eq Router_Changed : bool = (SubscribeResult.EvaluteValue.Cmd_Called = SUCCESS )or
						(UnsubscribeResult.EvaluteValue.Cmd_Called = SUCCESS);
--		    respectively manage each router;
--initially, set each subscription   into false
			guarantee "initialize all subscription to event into false mode":
			(
				OldRouteData.Event_Router.RouteList.ES_Pipe = false and 
				OldRouteData.Event_Router.RouteList.SB_Pipe = false and 
				OldRouteData.Event_Router.RouteList.EVS_Pipe = false and 
				OldRouteData.Event_Router.RouteList.TIME_Pipe = false and 
				OldRouteData.Event_Router.RouteList.Sample_APP_Pipe = false 
			) -> true;
			
			guarantee "initialize all subscription to core msg into false mode":
			(
				OldRouteData.Core_Msg_Router.RouteList.ES_Pipe = false and 
				OldRouteData.Core_Msg_Router.RouteList.SB_Pipe = false and 
				OldRouteData.Core_Msg_Router.RouteList.EVS_Pipe = false and 
				OldRouteData.Core_Msg_Router.RouteList.TIME_Pipe = false and 
				OldRouteData.Core_Msg_Router.RouteList.Sample_APP_Pipe = false 
			) -> true;
			
			guarantee "initialize all subscription to common msg into false mode":
			(
				OldRouteData.Common_Msg_Router.RouteList.ES_Pipe = false and 
				OldRouteData.Common_Msg_Router.RouteList.SB_Pipe = false and 
				OldRouteData.Common_Msg_Router.RouteList.EVS_Pipe = false and 
				OldRouteData.Common_Msg_Router.RouteList.TIME_Pipe = false and 
				OldRouteData.Common_Msg_Router.RouteList.Sample_APP_Pipe = false 
			) -> true;
			
			guarantee "manage event router": true -> 
			if (SubscribeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				SubscribeResult.EvaluteValue.Modified_RouteId = 0)
			then (OldRouteData.Event_Router  = SubscribeResult.Input.Event_Router)
			else if (UnsubscribeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				UnsubscribeResult.EvaluteValue.Modified_RouteId = 0)
			then (OldRouteData.Event_Router  = UnsubscribeResult.Input.Event_Router)
			else OldRouteData.Event_Router = pre(OldRouteData.Event_Router);
			
			
			guarantee "manage core msg router": true -> 
			if (SubscribeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				SubscribeResult.EvaluteValue.Modified_RouteId = 0)
			then (OldRouteData.Core_Msg_Router  = SubscribeResult.Input.Core_Msg_Router)
			else if (UnsubscribeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				UnsubscribeResult.EvaluteValue.Modified_RouteId = 0)
			then (OldRouteData.Core_Msg_Router  = UnsubscribeResult.Input.Core_Msg_Router)
			else OldRouteData.Core_Msg_Router = pre(OldRouteData.Core_Msg_Router);
			
			
			guarantee "manage common msg router": true -> 
			if (SubscribeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				SubscribeResult.EvaluteValue.Modified_RouteId = 0)
			then (OldRouteData.Common_Msg_Router  = SubscribeResult.Input.Common_Msg_Router)
			else if (UnsubscribeResult.EvaluteValue.Cmd_Called = SUCCESS and 
				UnsubscribeResult.EvaluteValue.Modified_RouteId = 0)
			then (OldRouteData.Common_Msg_Router  = UnsubscribeResult.Input.Common_Msg_Router)
			else OldRouteData.Common_Msg_Router = pre(OldRouteData.Common_Msg_Router);
	 
		**};
	end ShareData;

end SB_Service;
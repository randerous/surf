package ES_Processor
public
	with Generic;
	with ES_Arg_IO;
	with ES_Result_IO;
	
	--------all abstract can add external data corresponding to its require
	--only return changed data to help ShareData to maintain all global data
	abstract RegisterApp extends Generic::FunctionProcessor
		features
			Args: refined to feature group ES_Arg_IO::RegisterAppArgs;
			Results: refined to feature group ES_Result_IO::RegisterAppOutput;
			LocalDatas: refined to feature group ES_Result_IO::Input;
		annex agree{**
			--error num is defined in Results defining.
			--    for return value
			--    SUCCESS:0 
			--    CFE_ES_ERR_APP_REGISTER: 17
			--    UnCalled: -1
			eq SUCCESS : int = 0;
			eq CFE_ES_ERR_APP_REGISTER: int  = 17;
			eq MAX_APPID : int  = 512;
			
			eq Check_Args_False : bool = Args.a.TaskId >  MAX_APPID or Args.a.TaskId   < 0;
			guarantee "return null for No Call ": Args.a.In_Used = false => Results.ReturnValue.Cmd_Called = -1;
			guarantee "send error event when getting in trouble by return error num": true -> 
			true-> (Args.a.In_Used = true and Check_Args_False = true) =>
			 Results.ReturnValue.Cmd_Called = CFE_ES_ERR_APP_REGISTER;
			
			guarantee "activiate es taskRecord when call register basing on localData":  
			true->(Args.a.In_Used = true and Check_Args_False = false and Args.a.TaskId = 0) =>
			Results.ReturnValue.Cmd_Called = SUCCESS and 
			Results.ReturnValue.Modified_Id = 0 and 
			--Results.Output.TaskRecord.ES.AppId = 0  and 
			Results.Output.TaskRecord.ES.TaskId = 0  and 
			Results.Output.TaskRecord.ES.RecordUsed = true;
			--Results.Output.TaskRecord.ES.ExecutionCounter = 0 ;  let runloop deal with this counter 
			
			guarantee "activiate sb taskRecord when call register basing on localData":  
			true->(Args.a.In_Used = true and Check_Args_False = false and Args.a.TaskId = 1) =>
			Results.ReturnValue.Cmd_Called = SUCCESS and 
			Results.ReturnValue.Modified_Id = 1 and 
			Results.Output.TaskRecord.SB.TaskId = 1  and 
			Results.Output.TaskRecord.SB.RecordUsed = true;
			
			guarantee "activiate evs taskRecord when call register basing on localData":  
			true->(Args.a.In_Used = true and Check_Args_False = false and Args.a.TaskId = 2) =>
			Results.ReturnValue.Cmd_Called = SUCCESS and 
			Results.ReturnValue.Modified_Id = 2 and 
			Results.Output.TaskRecord.EVS.TaskId = 2  and 
			Results.Output.TaskRecord.EVS.RecordUsed = true;
			
			guarantee "activiate TIME taskRecord when call register basing on localData":  
			true->(Args.a.In_Used = true and Check_Args_False = false and Args.a.TaskId = 3) =>
			Results.ReturnValue.Cmd_Called = SUCCESS and 
			Results.ReturnValue.Modified_Id = 3 and 
			Results.Output.TaskRecord.TIME1.TaskId = 3  and 
			Results.Output.TaskRecord.TIME1.RecordUsed = true;
			
			guarantee "activiate HS_APP taskRecord when call register basing on localData":  
			true->(Args.a.In_Used = true and Check_Args_False = false and Args.a.TaskId = 5) =>
			Results.ReturnValue.Cmd_Called = SUCCESS and 
			Results.ReturnValue.Modified_Id = 5 and 
			Results.Output.TaskRecord.HS_APP.TaskId = 5  and 
			Results.Output.TaskRecord.HS_APP.RecordUsed = true;
			
		**};
	end RegisterApp;
	
	abstract RestartApp extends Generic::FunctionProcessor
		features
			Args: refined to feature group ES_Arg_IO::RestartAppArgs;
			Results: refined to feature group ES_Result_IO::RestartAppOutput;
			LocalDatas: refined to feature group ES_Result_IO::Input;
		annex agree{**
			--core service support the stable running of surf
			--Normally, we don't hope it down.
			--So, if restart appId is in [0,3], there will be an exception to be reported.
			--In fact, the restart cmd is very important. 
			eq SUCCESS : int = 0; 
			eq MAX_APPID : int  = 512;
			eq ES_ERR_APPID: int = 1;
			eq RESTART_CORE: int = 20;
			--eq Check_Args_False : bool = Args.a.TaskId >  MAX_APPID or Args.a.TaskId   < 0;
			--there are two app esApp and HS that will try to restart app, but to keep consistent.
			--we need it to be Mutually exclusive
			assume "only one restart cmd at the same time": 
			not(Args.ES_RestartApp.In_Used = true 
			and Args.HS_MonitorApplications_RestartApp.In_Used = true);
			
			guarantee "return null for No Call ": (Args.ES_RestartApp.In_Used = false 
			and Args.HS_MonitorApplications_RestartApp.In_Used = false)  => 
			Results.ReturnValue.Cmd_Called = -1;
			
			--when restart app, we need to check
			--(1) whether appId is core service
			--	  if yes, return  ES_ERR_APPID,(is set to RESTART_CORE) 
			--		perhaps, we need to change it to be different from common app's Error
			--(2) whether the state of appId is running, 
			--    if yes, then change its appControlRequest to RESTART, then wait esApp to change its runstate
			---   if not, return ES_ERR_APPID
			
			eq check_is_core_HsCall: bool = Args.HS_MonitorApplications_RestartApp.AppId < 4 
			 						and Args.HS_MonitorApplications_RestartApp.AppId >= 0 ;
			eq check_is_core_EsCall: bool = Args.ES_RestartApp.AppId < 4 
			 						and Args.ES_RestartApp.AppId >= 0 ;
			guarantee "Cannot restart core app": true -> 
			(Args.ES_RestartApp.In_Used = true and  check_is_core_EsCall)
			or( Args.HS_MonitorApplications_RestartApp.In_Used = true and check_is_core_HsCall) 
			=> Results.ReturnValue.Cmd_Called = RESTART_CORE;
			
			--0: running 1: restart, 2:waitting
			eq running : int = 0;
			eq restart : int = 1;
			eq waitting: int = 2;
			guarantee "Cannot restart app that is not running": true -> 
			(Args.ES_RestartApp.In_Used = true and  not check_is_core_EsCall and Args.ES_RestartApp.AppId = 5
			and LocalDatas.AppRecord.HS_APP.StateRecord.AppState <> running)
			=> Results.ReturnValue.Cmd_Called = ES_ERR_APPID;
			
			eq SYS_START : int = 5;
			eq TIME_OUT: int = 5;
			--there is something strange; there need to be some other common app to restart;
			guarantee "restart hs app ": true -> 
			(Args.ES_RestartApp.In_Used = true and  not check_is_core_EsCall and Args.ES_RestartApp.AppId = 5
			and LocalDatas.AppRecord.HS_APP.StateRecord.AppState = running)
			=> Results.ReturnValue.Cmd_Called = SUCCESS
			  and Results.ReturnValue.Modified_Id = 5
			  and Results.Output.AppRecord.HS_APP.RecordUsed = pre(LocalDatas.AppRecord.HS_APP.RecordUsed)
			  and Results.Output.AppRecord.HS_APP.AppType = pre(LocalDatas.AppRecord.HS_APP.AppType) 
			  and Results.Output.AppRecord.HS_APP.StartParams = pre(LocalDatas.AppRecord.HS_APP.StartParams) 
			  and Results.Output.AppRecord.HS_APP.TaskInfo = pre(LocalDatas.AppRecord.HS_APP.TaskInfo) 
			  and Results.Output.AppRecord.HS_APP.StateRecord.AppControlRequest = SYS_START
			  and Results.Output.AppRecord.HS_APP.StateRecord.AppState = waitting
			  and Results.Output.AppRecord.HS_APP.StateRecord.AppTimer = TIME_OUT;
			  
			
			
		**};
	end RestartApp;
	
	abstract DeleteApp extends Generic::FunctionProcessor
		features
			Args: refined to feature group ES_Arg_IO::DeleteAppArgs;
			Results: refined to feature group ES_Result_IO::DeleteAppOutput;
			LocalDatas: refined to feature group ES_Result_IO::Input;
	end DeleteApp;
	
	abstract RunLoop extends Generic::FunctionProcessor
		features
			Args: refined to feature group ES_Arg_IO::RunLoopArgs;
			Results: refined to feature group ES_Result_IO::RunLoopOutput;
			LocalDatas: refined to feature group ES_Result_IO::Input;
	end RunLoop;
end ES_Processor;
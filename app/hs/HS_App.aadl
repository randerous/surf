package HS_App
public
	with Component;
	with ES_Base_IO;
	with HS_Base_Task;
	with HS_Sugar;
	
	thread HSAPP extends Component::AppComponent
		features
			EVSAPI: refined to feature group HS_Sugar::EVSAPIOutput;
			ESAPI: refined to feature group HS_Sugar::ESAPIOutput;
			
			AppRecord: feature group ES_Base_IO::AppRecordInput;
		annex agree{**
			--MonitorApplications
			--there should be more monitor threads running at same time
			--need to control concurrency for all monitors!!!
			
			eq EVS_ERROR: int = 3;
			eq ERR_REPORT: int = 5;
			guarantee "monitor event, send error Msg for reporting":
			true -> 
			(	
				(Command.MsgId = 0 and Command.EvtId = EVS_ERROR)
				=> EVSAPI.SendEventArgs.Default.EvtId = ERR_REPORT
			);
			
			guarantee "monitor es, send a cmd to restart es whenever es stuck": true-> 
			(AppRecord.ES.StateRecord.AppTimer = pre(AppRecord.ES.StateRecord.AppTimer)) =>
			ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 0;
			
			guarantee "monitor sb, send a cmd to restart sb whenever sb stuck": true-> 
			(AppRecord.SB.StateRecord.AppTimer = pre(AppRecord.SB.StateRecord.AppTimer)) =>
			ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 1;
			
			guarantee "monitor evs, send a cmd to restart evs whenever evs stuck": true-> 
			(AppRecord.EVS.StateRecord.AppTimer = pre(AppRecord.EVS.StateRecord.AppTimer)) =>
			ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 2;
			
			guarantee "monitor TIME, send a cmd to restart TIME whenever TIME stuck": true-> 
			(AppRecord.Time1.StateRecord.AppTimer = pre(AppRecord.Time1.StateRecord.AppTimer)) =>
			ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 3;
			
			guarantee "monitor HS_APP, send a cmd to restart HS_APP whenever HS_APP stuck": true-> 
			(AppRecord.HS_APP.StateRecord.AppTimer = pre(AppRecord.HS_APP.StateRecord.AppTimer)) =>
			ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 5;
			
		**};
	end HSAPP;
	
	thread implementation HSAPP.impl extends Component::AppComponent.default
		subcomponents
			Medium: refined to abstract HS_Sugar::Medium;
			Checker: refined to abstract HS_Sugar::Checker;
			MonitorApplications: abstract HS_Base_Task::MonitorApplications;
		connections
			CheckerResult: port Checker.Result -> MonitorApplications.Execution;
			
			----------------Task data needed
			MonitorApplications_AppRecord: feature group AppRecord -> MonitorApplications.AppRecord;
			
			----------------Medium processor api call collecttion connection			
			MonitorApplications_RestartApp: feature group MonitorApplications.RestartApp.SB <-> Medium.ESAPIIn.RestartAppCollection.MonitorApplications_SB;
	end HSAPP.impl;
end HS_App;
package Surf
public
	with Core;
	with ES_App;
	with SB_App;
	with EVS_App;
	with TIME_App;
	with HS_App;
	with Sample_App;
	with Surf_Medium;
		
	process Surf
	
	-- no real meaning, just AGREE tool needs annex clause in component type
	annex agree{**
		 guarantee "": true;
	**};
	end Surf;
	
	process implementation Surf.impl
		subcomponents
			Core: abstract Core::Core.impl;
			ES: thread ES_App::ESAPP.impl;
			SB: thread SB_App::SBAPP.impl;
			EVS: thread EVS_App::EVSAPP.impl;
			TIME: thread TIME_App::TIMEApp.impl;
			HS: thread HS_App::HSApp.impl;
			Sample: thread Sample_App::SampleApp.impl;
			
			Medium: abstract Surf_Medium::Medium;
		connections
			---------------------core data provide---------------------------
			ES_AppRecord: feature group Core.AppRecord -> ES.AppRecord;
			HS_AppRecord: feature group Core.AppRecord -> HS.AppRecord;
			
			----------------------------Control command---------------------
			HS_Control: port ES.HSControlCommand -> HS.ControlCommand;
			
			---------------------------Medium--------------------------------
			MediumIn: feature group Core.MsgOutput -> Medium.MsgInput;
			
			----------------------------Msg----------------------------------
			ES_Command: port Medium.ES_CmdPipe_ES_Command -> ES.Command;
			SB_Command: port Medium.SB_CmdPipe_SB_Command -> SB.Command;
			EVS_Command: port Medium.EVS_CmdPipe_EVS_Command -> EVS.Command;
			TIME_Command: port Medium.TIME_CmdPipe_TIME_Command -> TIME.Command;
			HS_Command: port Medium.HS_CmdPipe_HS_Command -> HS.Command;
			
			------------------------------Function call----------------------
			ES_RestartApp_RestartApp: feature group ES.ESAPI.RestartAppArgs.RestartApp <-> Core.ESAPI.RestartAppArgs.ES_RestartApp;
			HS_MonitorApplications_RestartApp: feature group HS.ESAPI.RestartAppArgs.MonitorApplications_SB <-> Core.ESAPI.RestartAppArgs.HS_MonitorApplications_RestartApp;
			
--			ES_Default_SendEvent: feature group ES.EVSAPI.SendEventArgs.Default <-> Core.EVSAPI.SendEventArgs.ES_Default;
--			SB_Default_SendEvent: feature group SB.EVSAPI.SendEventArgs.Default <-> Core.EVSAPI.SendEventArgs.SB_Default;
--			EVS_Default_SendEvent: feature group EVS.EVSAPI.SendEventArgs.Default <-> Core.EVSAPI.SendEventArgs.EVS_Default;
--			TIME_Default_SendEvent: feature group TIME.EVSAPI.SendEventArgs.Default <-> Core.EVSAPI.SendEventArgs.TIME_Default;
--			HS_Default_SendEvent:  feature group HS.EVSAPI.SendEventArgs.Default <-> Core.EVSAPI.SendEventArgs.HS_Default;
--			ES_RestartApp_SendEvent: feature group ES.EVSAPI.SendEventArgs.RestartApp <-> Core.EVSAPI.SendEventArgs.ES_RestartApp;
			
			annex agree{**
			--0: running 1: restart  ÖØÆô 2: wait
			--
			eq SUCCESS: int = 0;
			eq ERR_APPID: int = 1;--AppId£¬
			
			eq INVALID_PIPE: int = 2;--
			eq BAD_ARGUMENT: int = 3;--
			eq MAX_PIPES_MET: int = 4;--
			eq PIPE_CR_ERR: int = 5;--
			
			eq MAX_MSGS_MET: int = 6;--
			eq MAX_DESTS_MET: int = 7;--
			eq BUF_ALOC_ERR: int = 8;--¢ï
			
			eq MSG_TOO_BIG: int = 9;
			
			eq APP_ILLEGAL_APP_ID: int = 10;-- 
			eq UNKNOWN_FILTER: int = 11;--
			eq ERR_BUFFER: int = 12;--
			
			eq APP_NOT_REGISTERED: int = 13; --=
			
			eq NO_MESSAGE: int = 14; --
			eq TIME_OUT: int = 15;--
			eq PIPE_RD_ERR: int = 16;--
			--MonitorApplications
			--there should be more monitor threads running at same time
			--need to control concurrency for all monitors!!!
			
			eq EVS_ERROR: int = 3;
			eq ERR_REPORT: int = 5;
			 
			lemma "hs monitor event, send error Msg for reporting":
			true -> 
			(	
				(HS.Command.MsgId = 0 and HS.Command.EvtId = EVS_ERROR)
				=>true 
--HS.EVSAPI.SendEventArgs.Default.EvtId = ERR_REPORT
			);
			
			lemma "hs monitor es, send a cmd to restart es whenever es stuck": true-> 
			(HS.AppRecord.ES.StateRecord.AppTimer = pre(HS.AppRecord.ES.StateRecord.AppTimer)) =>
			HS.ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 0;
			
			lemma "hs monitor sb, send a cmd to restart sb whenever sb stuck": true-> 
			(HS.AppRecord.SB.StateRecord.AppTimer = pre(HS.AppRecord.SB.StateRecord.AppTimer)) =>
			HS.ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 1;
			
			lemma "hs monitor evs, send a cmd to restart evs whenever evs stuck": true-> 
			(HS.AppRecord.EVS.StateRecord.AppTimer = pre(HS.AppRecord.EVS.StateRecord.AppTimer)) =>
			HS.ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 2;
			
			lemma "hs monitor TIME, send a cmd to restart TIME whenever TIME stuck": true-> 
			(HS.AppRecord.TIME1.StateRecord.AppTimer = pre(HS.AppRecord.TIME1.StateRecord.AppTimer)) =>
			HS.ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 3;
			
			lemma "hs monitor HS_APP, send a cmd to restart HS_APP whenever HS_APP stuck": true-> 
			(HS.AppRecord.HS_APP.StateRecord.AppTimer = pre(HS.AppRecord.HS_APP.StateRecord.AppTimer)) =>
			HS.ESAPI.RestartAppArgs.MonitorApplications_SB.AppId = 5;
 
--			
--			guarantee "GetTime": true -> TIME_API.GetTime.Valid = true => 
--			TIME_API.GetTime.Result = SUCCESS;

**};
	   
end Surf.impl;
end Surf;